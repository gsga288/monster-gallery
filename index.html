<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>轮廓＋内部生命游戏（纯色轮廓版）</title>
  <style>
    body,html { margin:0; padding:0; background:#000; overflow:hidden; }
    #container { position:relative; width:100vw; height:100vh; }
    canvas { position:absolute; top:0; left:0; image-rendering:pixelated; }
    #bg   { z-index:1; } /* 纯色轮廓 */
    #life { z-index:2; } /* 内部演化 */
  </style>
</head>
<body>
  <div id="container">
    <canvas id="bg"></canvas>
    <canvas id="life"></canvas>
  </div>
  <script>
  /* —— 参数 —— */
  const CELL      = 4;
  const COLS      = 200, ROWS = 150;
  const TICK      = 80;       // ms/步
  const THRESH    = 120;      // 亮度阈值
  const FILL_RATE = 0.4;      // 内部随机填充率

  /* —— 画布上下文 —— */
  const bgC  = document.getElementById('bg');
  const lifeC= document.getElementById('life');
  [bgC, lifeC].forEach(c=>{ c.width = COLS*CELL; c.height = ROWS*CELL; });
  const bgCtx   = bgC.getContext('2d');
  const lifeCtx = lifeC.getContext('2d');

  /* —— 数据结构 —— */
  let mask   = Array.from({length:ROWS},()=>Array(COLS).fill(0));
  let border = Array.from({length:ROWS},()=>Array(COLS).fill(0));
  let grid   = Array.from({length:ROWS},()=>Array(COLS).fill(0));
  let buf    = Array.from({length:ROWS},()=>Array(COLS).fill(0));

  /* —— 加载图像 —— */
  const img = new Image();
  img.src = 'creature.png';  // 你的原图
  img.onload = () => {
    buildMaskAndBorder();
    seedInterior();
    buildSilhouette();  // <- 这一步生成纯色轮廓画布
    loop();
  };

  /* —— 1) 从原图提取 mask & border —— */
  function buildMaskAndBorder(){
    const tmp = document.createElement('canvas');
    tmp.width=COLS; tmp.height=ROWS;
    const t  = tmp.getContext('2d');
    t.drawImage(img,0,0,COLS,ROWS);
    const D  = t.getImageData(0,0,COLS,ROWS).data;

    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const i   = (y*COLS+x)*4;
        const lum = (D[i]+D[i+1]+D[i+2])/3;
        mask[y][x] = lum > THRESH ? 1 : 0;
      }
    }
    // 4 邻不全在 mask 就是骨架
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        if(!mask[y][x]) continue;
        let n=0;
        [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
          n += mask[(y+dy+ROWS)%ROWS][(x+dx+COLS)%COLS];
        });
        if(n<4) border[y][x]=1;
      }
    }
  }

  /* —— 2) 在骨架内/外做初始填充 —— */
  function seedInterior(){
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        if(border[y][x]) {
          grid[y][x] = 1;      // 骨架永存
        } else if(mask[y][x]) {
          grid[y][x] = (Math.random() < FILL_RATE) ? 1 : 0;
        } else {
          grid[y][x] = 0;
        }
      }
    }
  }

  let silC, silCtx;
  /* —— 3) 生成“纯色轮廓”画布 —— */
  function buildSilhouette(){
    silC = document.createElement('canvas');
    silC.width = COLS; silC.height = ROWS;
    silCtx = silC.getContext('2d');
    silCtx.clearRect(0,0,COLS,ROWS);
    silCtx.fillStyle = '#0f0';
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        if(mask[y][x]){
          silCtx.fillRect(x, y, 1, 1);
        }
      }
    }
    // 把 1px 格子图 缩放到像素格大小并绘到 #bg
    bgCtx.clearRect(0,0,bgC.width,bgC.height);
    bgCtx.imageSmoothingEnabled = false;
    bgCtx.drawImage(silC, 0, 0, bgC.width, bgC.height);
  }

  /* —— 4) 演化一步 —— */
  function step(){
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        if(border[y][x]) {
          buf[y][x] = 1;
        } else {
          let n=0;
          for(let dy=-1;dy<=1;dy++){
            for(let dx=-1;dx<=1;dx++){
              if(dx||dy){
                const yy=(y+dy+ROWS)%ROWS;
                const xx=(x+dx+COLS)%COLS;
                n += grid[yy][xx];
              }
            }
          }
          buf[y][x] = (n===3 || (grid[y][x]&&n===2)) ? 1 : 0;
        }
      }
    }
    [grid,buf] = [buf,grid];
  }

  /* —— 5) 渲染内部CA —— */
  function drawLife(){
    lifeCtx.clearRect(0,0,lifeC.width,lifeC.height);
    lifeCtx.fillStyle = '#0f0';
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        // 只画「mask 内非骨架」的活细胞
        if(grid[y][x] && !border[y][x]){
          lifeCtx.fillRect(x*CELL, y*CELL, CELL, CELL);
        }
      }
    }
  }

  /* —— 6) 循环 —— */
  function loop(){
    step();
    drawLife();
    setTimeout(loop, TICK);
  }
  </script>
</body>
</html>


