<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>有机漂浮的生命体</title>
  <style>
    body,html {margin:0; padding:0; background:#000; overflow:hidden;}
    #container { position:relative; width:100vw; height:100vh; }
    canvas { position:absolute; top:0; left:0; image-rendering:pixelated; }
    #bg  { z-index:1; }   /* 背景轮廓 */
    #life{ z-index:2; }   /* 边缘生命游戏 */
  </style>
</head>
<body>
  <div id="container">
    <canvas id="bg"></canvas>
    <canvas id="life"></canvas>
  </div>
  <script>
  // —— 参数 —— 
  const CELL   = 4;        // 网格块大小
  const COLS   = 200, ROWS = 150;
  const THRESH = 120;      // 亮度阈值
  const TICK   = 80;       // 演化间隔 ms
  const AMPL   = 20;       // 漂浮振幅 px
  const SPEED  = 0.002;    // 漂浮速度

  // —— 画布 & 上下文 —— 
  const bgC  = document.getElementById('bg');
  const life = document.getElementById('life');
  [bgC,life].forEach(c=>{
    c.width = COLS*CELL; c.height = ROWS*CELL;
  });
  const bgCtx   = bgC.getContext('2d');
  const lifeCtx = life.getContext('2d');

  // —— 数据 —— 
  let mask   = Array.from({length:ROWS},()=>Array(COLS).fill(0)); // 形体掩码
  let edge   = Array.from({length:ROWS},()=>Array(COLS).fill(0)); // 边缘格点
  let grid   = Array.from({length:ROWS},()=>Array(COLS).fill(0));
  let buffer = Array.from({length:ROWS},()=>Array(COLS).fill(0));

  // —— 加载图像 —— 
  const img = new Image();
  img.src = 'creature.png';
  img.onload = () => {
    seedMask();
    seedEdges();
    drawMask();
    loop();
  };

  // —— 1) 从图像生成 mask —— 
  function seedMask(){
    // 把图缩到格子尺寸
    const tmp = document.createElement('canvas');
    tmp.width = COLS; tmp.height = ROWS;
    const tctx = tmp.getContext('2d');
    tctx.drawImage(img,0,0,COLS,ROWS);
    const D = tctx.getImageData(0,0,COLS,ROWS).data;
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const i=(y*COLS+x)*4;
        const lum = (D[i]+D[i+1]+D[i+2])/3;
        mask[y][x] = (lum>THRESH) ? 1 : 0;
      }
    }
  }

  // —— 2) 找到 mask 的“边缘” —— 
  function seedEdges(){
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        if(!mask[y][x]) continue;
        // 只要有任意 4 邻点非 mask，就算边缘
        const n = (mask[(y+1)%ROWS][x]||0)
                + (mask[(y-1+ROWS)%ROWS][x]||0)
                + (mask[y][(x+1)%COLS]||0)
                + (mask[y][(x-1+COLS)%COLS]||0);
        edge[y][x] = (n < 4) ? 1 : 0;
        // 初始演化格子只播 seed 边缘
        grid[y][x] = edge[y][x];
      }
    }
  }

  // —— 3) 画出静态轮廓 —— 
  function drawMask(){
    bgCtx.clearRect(0,0,bgC.width,bgC.height);
    bgCtx.drawImage(img,0,0,bgC.width,bgC.height);
  }

  // —— 4) 生命游戏演化（仅限在 edge 区域） —— 
  function step(){
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const isEdge = edge[y][x];
        if(!isEdge){
          buffer[y][x] = 0;
        } else {
          let n=0;
          for(let dy=-1;dy<=1;dy++)
          for(let dx=-1;dx<=1;dx++) if(dx||dy){
            const yy=(y+dy+ROWS)%ROWS;
            const xx=(x+dx+COLS)%COLS;
            n += grid[yy][xx];
          }
          buffer[y][x] = (n===3 || (grid[y][x]&&n===2)) ? 1 : 0;
        }
      }
    }
    [grid,buffer] = [buffer,grid];
  }

  // —— 5) 渲染 & 有机漂浮 —— 
  let t0 = performance.now();
  function draw(){
    // 生命层
    lifeCtx.clearRect(0,0,life.width,life.height);
    lifeCtx.fillStyle = '#0f0';
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        if(grid[y][x]){
          lifeCtx.fillRect(x*CELL,y*CELL,CELL,CELL);
        }
      }
    }
    // 漂浮效果
    const dt = performance.now() - t0;
    const dx = Math.sin(dt * SPEED) * AMPL;
    const dy = Math.cos(dt * SPEED * 0.7) * AMPL;
    // 把 container 做 translate
    document.getElementById('container').style.transform =
      `translate(${dx}px,${dy}px)`;
  }

  // —— 6) 主循环 —— 
  function loop(){
    step();
    draw();
    setTimeout(loop, TICK);
  }
  </script>
</body>
</html>


